/**
 * Vertex AI Image Generation (Gemini Image)
 * Gemini Image (Nanobananaファミリー) を使用した画像生成
 *
 * グローバルエンドポイントを使用し、シンプルなリトライロジックを提供
 */

import { getVertexAI, MODELS, executeWithRetry } from "./vertex-client";
import { GenerateContentRequest, GenerateContentResult } from "@google-cloud/vertexai";
import type { ArtStyle, EmotionalState } from "@/core/types";
import type { CharacterDefinition } from "@/core/types";

/**
 * Base Character Image 生成（Text-to-Image）
 * リトライロジック付き
 *
 * @param character - キャラクター定義
 * @param artStyle - 画風
 * @returns 生成された画像URL（Data URL形式）
 */
export async function generateBaseCharacterImage(
  character: CharacterDefinition,
  artStyle: ArtStyle
): Promise<string> {
  const prompt = buildCharacterImagePrompt(character, artStyle);

  console.log("[Gemini Image] Generating base image for:", character.name);

  const imageUrl = await executeWithRetry(
    async () => {
      const vertexAI = getVertexAI();

      // Gemini Imageモデルを使用
      const model = vertexAI.getGenerativeModel({
        model: MODELS.IMAGE
      });

      const request: GenerateContentRequest = {
        contents: [{
          role: "user",
          parts: [{ text: prompt }]
        }]
      };

      const result: GenerateContentResult = await model.generateContent(request);

      // 画像URLまたはBase64データを抽出
      return extractImageFromResponse(result);
    },
    `generateBaseCharacterImage(${character.name})`,
    3
  );

  console.log("[Gemini Image] Base image generated:", imageUrl ? "Success" : "Failed");

  return imageUrl;
}

/**
 * Expression Variation 生成（Image-to-Image）
 * リトライロジック付き
 *
 * @param baseImageUrl - 基準画像URL（Data URL形式）
 * @param emotion - 感情状態
 * @param character - キャラクター定義
 * @returns 生成された画像URL（Data URL形式）
 */
export async function generateExpressionVariation(
  baseImageUrl: string,
  emotion: EmotionalState,
  character: CharacterDefinition
): Promise<string> {
  const prompt = buildExpressionPrompt(emotion, character);

  console.log("[Gemini Image] Generating expression:", emotion, "for", character.name);

  // Base Imageをバイト配列に変換（リトライ時に再利用するため事前に取得）
  const imageData = await fetchImageAsBase64(baseImageUrl);

  const imageUrl = await executeWithRetry(
    async () => {
      const vertexAI = getVertexAI();

      const model = vertexAI.getGenerativeModel({
        model: MODELS.IMAGE
      });

      // Base Imageを入力として使用（Image-to-Image）
      const request: GenerateContentRequest = {
        contents: [{
          role: "user",
          parts: [
            {
              // Base Imageを入力
              inlineData: {
                mimeType: "image/png",
                data: imageData
              }
            },
            {
              // 表情変更の指示
              text: prompt
            }
          ]
        }]
      };

      const result: GenerateContentResult = await model.generateContent(request);

      return extractImageFromResponse(result);
    },
    `generateExpressionVariation(${character.name}, ${emotion})`,
    3
  );

  console.log("[Gemini Image] Expression variation generated:", imageUrl ? "Success" : "Failed");

  return imageUrl;
}

/**
 * キャラクター画像プロンプト構築
 * visualDescriptionがある場合はそれを優先使用し、多様なキャラクターを生成
 */
function buildCharacterImagePrompt(
  character: CharacterDefinition,
  artStyle: ArtStyle
): string {

  // スタイルは描画技法のみ指定
  const styleDesc = {
    anime: "Japanese anime style, clean lines, vibrant colors, manga aesthetic",
    oil_painting: "oil painting style, rich textures, dramatic lighting, fine art quality",
    realistic: "photorealistic, detailed, natural lighting, professional portrait photography",
    sketch: "pencil sketch style, hand-drawn, artistic, detailed shading"
  }[artStyle];

  // ユニークなシード値（重複防止用）
  const uniqueSeed = character.id.split('_').pop() || character.name;
  const hashCode = uniqueSeed.split('').reduce((a, b) => ((a << 5) - a) + b.charCodeAt(0), 0);
  const uniqueTimestamp = Date.now();
  const randomVariation = Math.abs(hashCode % 1000);

  // visualDescriptionがある場合は優先使用（Geminiが生成した詳細な外見情報）
  if (character.visualDescription) {
    const vd = character.visualDescription;

    return `
Generate a character portrait in ${styleDesc}.

Unique Seed: ${uniqueTimestamp}-${randomVariation}

CHARACTER VISUAL DESCRIPTION (Generated by AI - MUST follow exactly):
- Ethnicity: ${vd.ethnicity}
- Hair Style: ${vd.hairStyle}
- Hair Color: ${vd.hairColor}
- Body Type: ${vd.bodyType}
- Facial Features: ${vd.facialFeatures}
- Clothing: ${vd.clothing}
- Distinguishing Features: ${vd.distinguishingFeatures}
- Overall Impression: ${vd.overallImpression}

Character Info:
- Name: ${character.name}
- Gender: ${character.gender}
- Age: ${character.age} years old
- Job: ${character.job}
- Personality: ${character.personality}

Composition:
- Upper body portrait, centered
- Neutral or calm expression
- Simple background appropriate for a mystery game
- High quality, professional look

CRITICAL RULES:
- Follow the visual description EXACTLY as specified above
- Character MUST look ${character.age} years old
- DO NOT include ANY text, letters, words, numbers, or symbols in the image
- NO watermarks, NO signatures, NO names, NO labels
- The image must be purely visual with ZERO text elements
- Make this character visually DISTINCT from all other characters
`;
  }

  // フォールバック: visualDescriptionがない場合は従来のルールベース
  console.log(`[Image Prompt] No visualDescription for ${character.name}, using fallback`);

  const ageAppearance = character.age < 20 ? "teenage appearance, youthful face" :
                        character.age < 25 ? "young adult, early twenties" :
                        character.age < 40 ? "adult appearance, mature features" :
                        character.age < 60 ? "middle-aged, distinguished look" :
                        "elderly, wise appearance";

  const jobClothing = getClothingForJob(character.job, character.gender);

  const hairColors = ["black hair", "dark brown hair", "brown hair", "light brown hair"];
  const hairColor = hairColors[Math.abs(hashCode) % hairColors.length];

  const maleHairStyles = ["short neat hair", "slightly messy hair", "slicked back hair", "medium length hair"];
  const femaleHairStyles = ["long straight hair", "shoulder-length hair", "ponytail", "short bob"];
  const hairStyle = character.gender === "female"
    ? femaleHairStyles[Math.abs(hashCode >> 2) % femaleHairStyles.length]
    : maleHairStyles[Math.abs(hashCode >> 2) % maleHairStyles.length];

  return `
Generate a character portrait in ${styleDesc}.

Unique Seed: ${uniqueTimestamp}-${randomVariation}

Character Identity:
- Name: ${character.name}
- Job/Role: ${character.job}
- Gender: ${character.gender}
- Age: ${character.age} years old (${ageAppearance})
- Personality: ${character.personality}

Appearance:
- Hair: ${hairColor}, ${hairStyle}
- Face: ${character.gender === "female" ? "feminine features" : "masculine features"}
- Clothing: ${jobClothing}

Composition:
- Upper body portrait, centered
- Neutral or calm expression
- Simple background appropriate for a mystery game
- High quality, professional look

CRITICAL RULES:
- Character MUST look ${character.age} years old
- DO NOT include ANY text, letters, words, numbers, or symbols
- NO watermarks, NO signatures, NO names, NO labels
- The image must be purely visual with ZERO text elements
`;
}

/**
 * 職業に応じた服装を取得
 */
function getClothingForJob(job: string, gender: string): string {
  const jobLower = job.toLowerCase();

  // 学生系
  if (jobLower.includes("学生") || jobLower.includes("生徒") || jobLower.includes("student")) {
    return gender === "female"
      ? "Japanese school uniform (sailor uniform or blazer with pleated skirt)"
      : "Japanese school uniform (gakuran or blazer with slacks)";
  }

  // 教師・教授系
  if (jobLower.includes("教師") || jobLower.includes("教授") || jobLower.includes("先生") || jobLower.includes("teacher") || jobLower.includes("professor")) {
    return gender === "female"
      ? "professional teacher attire (blouse and skirt or dress)"
      : "professional teacher attire (dress shirt, possibly with blazer)";
  }

  // 執事・メイド系
  if (jobLower.includes("執事") || jobLower.includes("butler")) {
    return "formal butler uniform (tailcoat, white shirt, bow tie)";
  }
  if (jobLower.includes("メイド") || jobLower.includes("maid")) {
    return "maid uniform (black dress with white apron)";
  }

  // 医療系
  if (jobLower.includes("医") || jobLower.includes("doctor") || jobLower.includes("nurse")) {
    return "medical professional attire (white coat or scrubs)";
  }

  // 警察・探偵系
  if (jobLower.includes("刑事") || jobLower.includes("警") || jobLower.includes("detective") || jobLower.includes("police")) {
    return "detective attire (suit or formal wear)";
  }

  // デフォルト
  return gender === "female"
    ? "elegant attire appropriate for their role"
    : "formal attire appropriate for their role";
}

/**
 * 表情変更プロンプト構築
 */
function buildExpressionPrompt(
  emotion: EmotionalState,
  character: CharacterDefinition
): string {

  const emotionDesc = {
    calm: "calm and composed, serene expression",
    angry: "angry with furrowed brows, intense gaze",
    nervous: "nervous with wide eyes, worried expression",
    sad: "sad with downcast eyes, melancholic expression",
    confident: "confident with a slight smile, determined look"
  }[emotion];

  return `
CRITICAL REQUIREMENT: Keep EVERYTHING the same except facial expression.
- Same clothing, hair, background, pose
- Same body position and framing
- ONLY change: facial expression to "${emotionDesc}"

Character: ${character.name}
Target emotion: ${emotion}

Modify ONLY the facial expression to show ${emotionDesc}.
Maintain all other aspects of the image unchanged.
`;
}

/**
 * Gemini Image レスポンスから画像URLを抽出
 */
function extractImageFromResponse(result: GenerateContentResult): string {
  const response = result.response;

  if (!response.candidates || response.candidates.length === 0) {
    throw new Error("No image generated - no candidates in response");
  }

  const candidate = response.candidates[0];

  if (!candidate.content || !candidate.content.parts) {
    throw new Error("No image generated - no content parts in response");
  }

  // Base64データまたはURLを探す
  const imagePart = candidate.content.parts.find((p: any) => p.inlineData);

  if (imagePart?.inlineData) {
    // Base64データの場合、Data URLに変換
    const mimeType = imagePart.inlineData.mimeType || "image/png";
    return `data:${mimeType};base64,${imagePart.inlineData.data}`;
  }

  // テキストからURLを抽出（Geminiが画像URLを返す場合）
  const textPart = candidate.content.parts.find((p: any) => p.text);
  if (textPart?.text) {
    const urlMatch = textPart.text.match(/https?:\/\/[^\s]+\.(png|jpg|jpeg|webp)/i);
    if (urlMatch) {
      return urlMatch[0];
    }
  }

  throw new Error("Failed to extract image URL from response");
}

/**
 * 画像URLをBase64データに変換
 * Data URL形式の場合はそのまま、HTTPSの場合はfetchして変換
 */
async function fetchImageAsBase64(url: string): Promise<string> {
  // すでにData URL形式の場合
  if (url.startsWith("data:")) {
    // data:image/png;base64,XXXX から XXXX 部分を抽出
    const base64Match = url.match(/^data:image\/[^;]+;base64,(.+)$/);
    if (base64Match) {
      return base64Match[1];
    }
  }

  // HTTPS URLの場合、fetchして変換
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  const buffer = Buffer.from(arrayBuffer);
  return buffer.toString('base64');
}

/**
 * 背景画像生成（Text-to-Image）
 * シナリオの舞台に合わせた背景画像を生成
 *
 * @param scenarioMeta - シナリオのメタデータ（title, genre, description）
 * @param artStyle - 画風
 * @param customPrompt - カスタムプロンプト（シナリオ生成時にAIが作成したもの）
 * @returns 生成された画像URL（Data URL形式）
 */
export async function generateBackgroundImage(
  scenarioMeta: { title: string; genre: string; description: string },
  artStyle: ArtStyle,
  customPrompt?: string
): Promise<string> {
  // カスタムプロンプトがあればそれを使用、なければテンプレートから生成
  const prompt = customPrompt
    ? buildBackgroundImagePromptFromCustom(customPrompt, artStyle)
    : buildBackgroundImagePrompt(scenarioMeta, artStyle);

  console.log("[Gemini Image] Generating background image for:", scenarioMeta.title);
  console.log("[Gemini Image] Using custom prompt:", !!customPrompt);

  const imageUrl = await executeWithRetry(
    async () => {
      const vertexAI = getVertexAI();

      const model = vertexAI.getGenerativeModel({
        model: MODELS.IMAGE
      });

      const request: GenerateContentRequest = {
        contents: [{
          role: "user",
          parts: [{ text: prompt }]
        }]
      };

      const result: GenerateContentResult = await model.generateContent(request);

      return extractImageFromResponse(result);
    },
    `generateBackgroundImage(${scenarioMeta.title})`,
    3
  );

  console.log("[Gemini Image] Background image generated:", imageUrl ? "Success" : "Failed");

  return imageUrl;
}

/**
 * カスタムプロンプトから背景画像プロンプトを構築
 * AIが生成したプロンプトに、スタイル指定とセーフティルールを追加
 */
function buildBackgroundImagePromptFromCustom(
  customPrompt: string,
  artStyle: ArtStyle
): string {
  const styleDesc = {
    anime: "Japanese anime style, clean lines, atmospheric, anime background art",
    oil_painting: "oil painting style, rich textures, dramatic lighting, fine art quality",
    realistic: "photorealistic, detailed, cinematic lighting, professional concept art",
    sketch: "pencil sketch style, hand-drawn, artistic, detailed shading"
  }[artStyle];

  return `
Generate a wide background image in ${styleDesc}.

SCENE DESCRIPTION (from scenario):
${customPrompt}

COMPOSITION REQUIREMENTS:
- Wide aspect ratio (approximately 21:9 or similar panoramic view)
- Atmospheric perspective with depth
- Suitable as a game background/map

CRITICAL SAFETY RULES (MUST FOLLOW):
- DO NOT include ANY text, letters, words, numbers, or symbols in the image
- NO watermarks, NO signatures, NO titles, NO labels
- NO people, characters, or silhouettes in the scene
- The image must be purely visual with ZERO text elements
- Create an immersive, atmospheric background for a murder mystery game
`;
}

/**
 * 背景画像プロンプト構築（フォールバック用テンプレート）
 */
function buildBackgroundImagePrompt(
  scenarioMeta: { title: string; genre: string; description: string },
  artStyle: ArtStyle
): string {
  const styleDesc = {
    anime: "Japanese anime style, clean lines, atmospheric, anime background art",
    oil_painting: "oil painting style, rich textures, dramatic lighting, fine art quality",
    realistic: "photorealistic, detailed, cinematic lighting, professional concept art",
    sketch: "pencil sketch style, hand-drawn, artistic, detailed shading"
  }[artStyle];

  // ジャンルに応じた舞台設定
  const genreSettings: Record<string, string> = {
    "Mansion": "a grand Victorian mansion interior, ornate decorations, dimly lit with candles, mysterious atmosphere",
    "SF": "a futuristic space station or cyberpunk city interior, neon lights, high-tech atmosphere",
    "School": "a Japanese school interior at dusk, empty hallways, atmospheric lighting through windows",
    "Hotel": "a luxurious hotel lobby or corridor, elegant decor, atmospheric lighting",
    "Hospital": "a hospital corridor or room, clinical yet eerie atmosphere, dramatic shadows",
    "Ship": "a cruise ship interior or deck, maritime atmosphere, mysterious fog",
  };

  const settingDescription = genreSettings[scenarioMeta.genre] ||
    "a mysterious interior setting appropriate for a murder mystery game, atmospheric lighting, dark academia aesthetic";

  return `
Generate a wide background image in ${styleDesc}.

Scene: ${settingDescription}

Context from scenario:
- Title: ${scenarioMeta.title}
- Setting: ${scenarioMeta.genre} mystery
- Description hint: ${scenarioMeta.description.substring(0, 200)}

Composition requirements:
- Wide aspect ratio (approximately 21:9 or similar)
- Atmospheric perspective
- Moody, mysterious lighting (candlelight, moonlight, or dramatic shadows)
- Dark Academia aesthetic
- Empty scene (NO people, NO characters)
- Suitable as a game background/map

CRITICAL RULES:
- DO NOT include ANY text, letters, words, numbers, or symbols in the image
- NO watermarks, NO signatures, NO titles, NO labels
- NO people or characters in the scene
- The image must be purely visual with ZERO text elements
- Create an immersive, atmospheric background for a murder mystery game
`;
}
